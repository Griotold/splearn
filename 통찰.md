# 강의를 들으면서 얻은 통찰

## 섹션 3. 도메일 모델이 이끄는 개발

### Member 엔티티 생성
- 테스트 코드는 도메인 규칙을 잘 지키는지를 검증해야 한다.

### Member 도메인 로직 개발
- 도메인 모델에 규칙을 상세히 적어두고, 테스트 코드는 그 규칙을 고대로 옮겨 놓는 것이다. 
  - `@DisplayName`은 필요할 때만 넣는다.
- 엔티티에 `org.springframework.util.Assert`를 적극적으로 사용하자.
- 하나의 테스트 코드에서 검증 하는 부분이 2개여도 괜찮다.

### 스프링을 이용한 `null`안전성 확보
- `SpotBugs` 플러그인을 활용해서 `null` 안전성을 확보하자.
- `JSR-305`, `@NonNull`, `@Nullable`

### Member 도메인 모델 확장
- 도메인 모델에서 패스워드 암호화를 해야한다.
- 정적 팩토리 메서드
- Test Fixture

### Member 도메인 코드 개선
- 파라미터가 길어질 때 해결 방법 -> 파라미터 오브젝트

### 도메인 모델 값 객체(Value Object) 도입
- 이메일은 유효성 검사가 필요하고, 매번 검사를 해줘야하니 값 객체로 만들어보자.
- 값 객체는 도메인 모델에서 식별자가 필요하지 않고 속성/값으로 만 구별되는 오브젝트이다.
  - 따라서, 동등성(equals, hashCode)을 보장해줘야 한다.
- 엔티티가 너무 많은 책임을 지는 것을 막는다.
- 변경이 필요하면 값 객체 자체를 변경해버린다.
- 풍부한 기능
- 자체 유효성 검사

## 섹션 4. 헥사고날 아키텍쳐

### 헥사고날 아키텍처의 사실과 오해(1, 2)
- 서비스 계층에서 인터페이스는 꼭 만들자.
- 헥사고날 아키텍쳐는 스프링의 핵심 원리를 잘 따르는 아키텍쳐다.
- 헥사고날 아키텍쳐는 사실 테스트를 위한 아키텍쳐였다.
  - 출발이 그렇다.
  - 따라서, 테스트를 안 만들면 헥사고날 아키텍쳐의 의미가...
- 헥사고날 아키텍쳐는 애플리케이션 내부 구현에 대한 원칙이나 요구사항이 없다.
  - 도메인 계층을 따로 두지 않아도 되고,
  - 트랜잭션 스크립트로 구현해도 되고,
  - 스파게티로 구현해도 무방하다.
- 코드 의존성은 내부로만 
  - [어댑터] -> [애플리케이션(포트 포함)] -> [도메인]
  - ![이미지](https://github.com/user-attachments/assets/1f2146fe-2aa2-4e5d-8be9-798d4b4513b4)

### 회원 애플리케이션의 포트 정의
- 인터페이스 명명 규칙: 자바에서는 명사 또는 형용사를 쓴다.
  - 명사: `List`, `Set`, `Map`, `Executor
  - 형용사: `Serializable`, `Comparable`, `iterable`

### 엔티티 식별자와 JPA 엔티티
- `MemberFixture`
```
package tobyspring.splearn.domain;

public class MemberFixture {

    public static PasswordEncoder createPasswordEncoder() {
        return new PasswordEncoder() {
            @Override
            public String encode(String password) {
                return password.toUpperCase();
            }

            @Override
            public boolean matches(String password, String passwordHash) {
                return encode(password).equals(passwordHash);
            }
        };
    }

    public static MemberRegisterRequest createMemberRegisterRequest(String email) {
        return new MemberRegisterRequest(email, "rio", "secret");
    }

    public static MemberRegisterRequest createMemberRegisterRequest() {
        return createMemberRegisterRequest("rio@splearn.app");
    }
}
```

### 엔티티의 자연키 지정
- `@NaturalId`
  - 데이터베이스의 기본 키(@Id)와는 별개로, 비즈니스 도메인에서 자연스럽게 엔티티를 식별할 수 있는 필드를 표시
  - 자동으로 해당 필드에 대한 유니크 제약조건이 생성됨
  - 예를 들어 중복된 이메일을 넣고 회원을 저장하려고하면 `DataIntegrityViolationException.class` 이게 발생함.
- `@NaturalIdCache`
  - 자연 식별자로 엔티티를 조회할 때 결과를 캐시에 저장 
  - 동일한 자연 식별자로 재조회 시 데이터베이스 접근 없이 캐시에서 반환 
  - Hibernate의 2차 캐시와 연동되어 작동

### 회원 애플리케이션 서비스 테스트 (1) - 단위 테스트 - stub, mock
- 테스트는 구현체에 하지 않고 인터페이스에 한다.
- 테스트에서 private 필드에 접근 시 `ReflectionTestUtils` 를 사용하자. 
#### Stub vs Mock vs Mockto
- Stub 
  - 테스트에 필요한 데이터만 제공하면 될 때
  - 호출 검증이 필요없을 때 
  - 간단한 테스트

- Mock 
  - 특정 메서드가 올바른 파라미터로 호출되었는지 검증해야 할 때 
  - 의존 객체와의 상호작용이 테스트의 핵심일 때

- Mockito 사용:
  - Mock/Stub을 쉽게 만들고 싶을 때 
  - 복잡한 검증이 필요할 때 
  - 코드를 간결하게 유지하고 싶을 때

### 회원 애플리케이션 서비스 테스트 (2) - 통합 테스트 - `@SpringBootTest`
- `DuplicateEmailException` 은 도메인 영역에
- 애플리케이션 서비스의 public 메서드(register) 는 추상화 수준이 높아야 한다.
```java
/**
* 애플리케이션 서비스의 public 메서드는 추상화 수준이 높아야 한다.
* 코드를 읽어나갈 때, 문서 처럼 읽혀야 한다.
* 그렇지 않으면 리팩토링이 필요하다.
* */
@Override
public Member register(MemberRegisterRequest registerRequest) {
  // check
  checkDuplicateEmail(registerRequest);

  // domain model
  Member member = Member.register(registerRequest, passwordEncoder);

  // repository
  memberRepository.save(member);

  // post process
  sendWelcomeEmail(member);
  return member;
}

private void sendWelcomeEmail(Member member) {
  emailSender.send(member.getEmail(), "등록을 완료해주세요.", "아래 링크를 클릭해서 등록을 완료해주세요.");
}

private void checkDuplicateEmail(MemberRegisterRequest registerRequest) {
  if (memberRepository.findByEmail(new Email(registerRequest.email())).isPresent()) {
      throw new DuplicateEmailException("이메일이 중복 됩니다.");
  }
}

```
- 테스트는 레코드로 만들면 간결해진다.
```java
@Transactional
@Import(SplearnTestConfiguration.class)
@SpringBootTest
public record MemberRegisterTest(MemberRegister memberRegister) {...}
```
- 근데, 이렇게 레코드로 만들려면 `@TestConstructor(autowireMode =  TestConstructor.AutowireMode.ALL)`이거를 넣어주던가
- resources>junit-platform.properties 에 `spring.test.constructor.autowire.mode=all` 를 추가해줘야 한다.

### 표준 유효성 검사 도구를 이용한 요청 데이터 검증
- 애플리케이션 서비스에서 밸리데이션(유효성 검증)을 하는 것이 좋다.
  - 방어적 프로그래밍 관점에서
- 컨트롤러에서는 `Spring MVC`가 `@Valid` 가 붙은 객체를 자동으로 검증해주지만,
- 서비스에서는 그렇지 못하기 때문에, 클래스 레벨에 `@Validated`를 붙여줘야 한다.
```java
@Validated
@Transactional
@RequiredArgsConstructor
@Service
public class MemberService implements MemberRegister {
    ...

    // 인터패이스에 선언부에 @Valid 가 붙어있기 때문에 구현체에서는 생략 가능하다 
    @Override
    public Member register(MemberRegisterRequest registerRequest) { ... }
}
---
/**
 * 회원의 등록 관련된기능을 제공한다.
 * */
public interface MemberRegister {

    Member register(@Valid MemberRegisterRequest registerRequest);
}
```